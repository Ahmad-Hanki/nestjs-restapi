install 
npm i argon2 @nestjs/jwt @nestjs/passport passport passport-jwt @nestjs/config
npm i -D @types/passport-jwt


// create the prisma server and module and init it
apps\restapi\src\prisma\prisma.service.ts
apps\restapi\src\prisma\prisma.module.ts

// create the user resources with crud
// create the custom response and custom exertion

apps\restapi\shared\response.interceptor.ts
apps\restapi\shared\all-exceptions.filter.ts
and implementing them in the main apps\restapi\src\main.ts

// create the login logic with generating access token and refresh tokens
apps\restapi\src\auth\auth.service.ts

// now create the jwt strategy 
apps\restapi\src\auth\guards\strategies\jwt.strategy.ts

now create the guard .. only rest apis
apps\restapi\src\auth\guards\jwt-auth.guard.ts

CurrentUser decorator
apps\restapi\shared\decorators\current-user.decorator.ts

// roles decorator
apps\restapi\shared\decorators\roles.decorator.ts

### 10) Using guards in resolvers (examples)

/// ADMIN only
 @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('ADMIN')
  @Delete(':id')
  async deleteUser(@Param('id') id: string) {
    return this.userService.delete(Number(id));
  }


  /// 2️⃣ Admin OR the user themself
  @UseGuards(JwtAuthGuard)
  @Patch(':id')
  async updateUser(
    @CurrentUser() user,
    @Param('id') id: string,
    @Body() updateUserDto: any, // replace with proper DTO
  ) {
    if (user.role !== 'ADMIN' && user.id !== Number(id)) {
      throw new ForbiddenException('Not allowed');
    }
    return this.userService.update(Number(id), updateUserDto);
  }

  3️⃣ Authenticated-only route (any role)
  @UseGuards(JwtAuthGuard)
  @Get('me')
  me(@CurrentUser() user) {
    return user;
  }

// auth module rewriting
apps/api/src/auth/auth.module.ts


hybrid jwt auth
apps\restapi\src\auth\guards\jwt-auth-optional.guard.ts
usage:

@UseGuards(OptionalJwtAuthGuard)
 @Get(':id')
  async getPost(@Param('id') id: string, @CurrentUser() user) {
    const post = await this.postService.getPostWithLikes(Number(id));

    let likedByUser = false;
    if (user) {
      likedByUser = await this.postService.checkIfUserLikedPost(user.id, Number(id));
    }

    return {
      ...post,
      likedByUser, // true or false, only if user is authenticated
    };
}



// JWT_SECRET in the env fil

///////////////////////////////////////////

// now google auth
pnpm i passport-google-oauth20
pnpm i -D @types/passport-google-oauth20

create apps\restapi\src\auth\strategies\google.strategy.ts

now go to google console api
https://console.cloud.google.com/
- create a project
- APIs & Services
- Credentials
- create credentials
- oAuth client Id
- web application
- Authorized JavaScript origins  // the domain which is http://localhost:8000
- Authorized redirect URIs // after the success => http://localhost:8000/auth/google/callback
in the env 
file GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=
GOOGLE_CALLBACK_URL=http://localhost:8000/api/auth/google/callback

- validateGoogleUser => apps\api\src\auth\auth.service.ts

/ now we will create googleAuthGarde
// apps\restapi\src\auth\guards\google-auth\google-auth.guard.ts

// now we will create googleAuthGarde
// apps\restapi\src\auth\guards\google-auth\google-auth.guard.ts

// now go to apps\api\src\auth\auth.module.ts and register the strategy
// apps\restapi\src\auth\auth.module.ts

// now we need 2 apis one for the login and one for the callback. we cant do it with graphql we need rest api
created the controllers
apps\restapi\src\auth\auth.controller.ts //

then in the api front the rest

now go to the apps\api\src\auth\auth.controller.ts
and create the verify function